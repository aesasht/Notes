# 第九章	内存模型和名称空间



## 内存模型

#### 				单独编译

​			和C语言一样，C++也允许甚至鼓励程序员将组件函数放在独立的文件中。
​			请不要将函数定义或变量申明放到头文件中。（两次定义相同变量将会引发编译错误）
​			头文件通常包含的内容：	使用#define或const定义的符号常量

  * 结构声明

  * 类声明

  * 模板声明

  * 内联函数

  * 函数原型

    将结构声明放在头文件中是可以的，因为它们不创建变量。

    

    ​	在同一个文件中只能将同一个头文件包含一次。记住这个规则很容易，但可能在不知情的情况下将头文件包含多次。有一种标准的C/C++技术可以避免多次包含同一头文件。

    ​	它是基于预处理器编译指令#ifndef的。

    ```C++
    #ifndef
    #define COORDIN_H
    ...
    ...
    #endif
    ```

    ​	编译器首次遇到该文件，名称COORDIN_H没有被定义。在这个情况下，编译器将会查看#ifndef和#endif之间的内容。如果在同一文件中遇到其他包含COORDIN_H文件,编译器将会知道COORDIN_H已经被定义了，从而跳到#endif那一行上。

    ### 	存储持续性、作用域和链接性

    ​	使用4种不同的方式来存储数据：

    * 自动存储持续性
    * 静态存储持续性
    * 线程存储持续性
    * 动态存储持续性：用new运算符分配的内存将一直存在，知道使用delete运算符将其释放或程序结束为止。

    ​	

​		作用域描述了名称在文件的多大范围内可见（与C语言的定义相同）

#### 		关键字register

​		关键字register最初是有C语言引入的，它建议编译器使用CPU寄存器来存储自动变量。在C++中只是显示地指出变量是自动地

#### 		静态持续变量

​		C++也为静态存储持续变量提供3种链接性：外部链接性（可在其他文件中访问）、内部链接性（只能在当前文件中访问）和无链接性（只能在当前函数或代码块里访问）。这些变量在程序存在期间一直存在。
​		介绍如何创建它们。要想创建链接性为外部的静态持续变量，必须在代码块外面声明它；要创建链接性为内部的静态持续变量，必须在代码块外面声明它，并使用static限定符；要创建没有链接性的静态变量，必须在代码块里面声明它，并使用static限定符。
​		未被初始化的静态变量的所有位都被设置为0。

### 静态持续性。外部链接性

​		链接性为外部的变量简称为外部变量，它们的存储持续性为静态，作用域为整个文件。

#### 	单定义规则

​		C++提供两种声明。一种是定义声明（defining declaration)或简称为定义（definition），它给变量分配空间；另外一种是引用声明（referencing declaration）或简称声明（declaration），它不给变量分配空间，因为它引用已有的变量。
​		引用声明使用关键字extern，且不进行初始化；否则，声明为定义，导致分配存储空间。	

```C++
double up;
extern int blem;
extern char gr = 'z';
```

​		如果要在多个文件中使用外部变量，只需在一个文件中包含改变量的定义（单定义规则），但在使用该变量的其他文件中，都必须使用关键字extern声明它：

```C++
//file01.cpp
extern int cats = 20;
int dogs = 22;
int fleas;
...


//file02.cpp
//use cats and dogs from file01.cpp
extern int cats;
extern int dogs;
...

```

​		单定义规则表明了，一个程序可能有相同的变量，但没个变量只能有一个定义。

​		C++比C语言更进一步——它提供了作用域解析运算符（::)。放在变量名前面时，该运算符表示使用变量的全局版本。相对于依赖于作用域规则而使用extern关键字，使用::运算符是更好的选择。
​		
​		外部存储尤其使用于表示常量数据，因为这样可以使用关键字const来防止数据被修改。

### 静态持续性、内部链接性

​		将static限定符用于整个文件的变量时，该变量的链接性将为内部的。可使用外部变量在多文件程序的不同部分共享数据；可使用链接性为内部的静态变量在同一个文件中的多个函数之间共享数据（名称空间提供了另外一种共享数据的方法）。

### 存储方案和动态分配

​		使用C++运算符new（或C语言的malloc()）分配的内存被称为动态内存。

## 名称空间

​		在C++中，名称可以是变量、函数、结构、枚举、类以及类和结构成员。当随着项目的规模扩大，名称相互冲突的可能性也在增大。使用多个厂商的类库时，可能导致名称的冲突。C++标准提供了名称空间工具，以便更好地控制名称地作用域。

### 		新的名称空间特性

​		C++新增了这样一种功能，即通过定义一种新的声明区域来创建命名的名称空间，这样做的目的之一是提供一个声明名称的区域，一个名称空间中的名称不会于另外一个名称空间的相同名称发生冲突，同时允许程序的其他部分使用该名称空间中声明的东西。使用关键字namespace来创建名称空间。

```C++
namespace Jack{
	double pall;
    void fetch();
    int pal;
	struct Well{...};
}

namespace Jill{
	double bucket( double n );
    void fetch();
}
```

​		名称空间可以是全局的，也可以位于另外一个名称空间中，但不能为于代码块中。
​		名称空间是开放的，即可以把名称加入到已有的名称空间里。下面将名称goose加入名称空间Jill中

```C++
namespace Jill{
	char * goose(const char *);
}
```

​		同样的，原来的Jack名称空间为fetch()函数提供原型。可以在该文件后面（或者是另外一个文件里）再次使用Jack名称空间来提供该函数的代码：

```C++
namespace Jack{
	void fetch(){
		...
    }
}
```

​		通过作用域解析运算符::,使用名称空间来限定该名称。

```C++
Jack::fetch();
Jack::pall = 12.34;
```

#### using声明和using编译指令

​		我们并不希望每次使用名称是都对它进行限定，因此C++提供了两种机制（using声明和using编译指令）来简化对名称空间的使用。using声明使特定的标识符可用，using编译指令使整个名称空间可用。
​		using声明由被限定的名称和它前面的关键字using组成。

```C++
using Jill::fetch();
```

​		完成该声明后，便可以使用名称fetch来代替Jill::fetch。

​		using声明使一个名称可用，而using编译指令使所有名称都可用。using编译指令由名称空间名和它前面的关键字using namespace组成，它使名称空间中的所有名称都可用，而不需要使用作用域解析运算符：

```C++
#include<iostream>		//places names in namespace std
using namespace std;	//make names available globally
```

​		在全局声明中使用using编译指令，将使一个名称空间全局可用。
​		在函数中使用using编译指令，将使其中的名称在该函数可用。

```C++
int main(){
	using namespace std;	//make names available in main()
	...
	return 0;
}
```

#### 		名称空间的其他特性

​		可以将名称空间声明进行嵌套。

```C++
namespace elements{
	namespace fire{
		int flame;
        ...;
    	
    }
	float water;
}
```

​        里面的flame是elements::fire ::flame
​		另外，也可以在名称空间里使用using编译指令和using声明。
​		

```C++
namespace myth{
	using Jill::fetch;
    using namespace element;
    using std::cout;
    using std::cin;
}
```

#### 名称空间及其前途

​		随着程序员逐渐熟悉名称空间，将出现同一的编程理念。下面是当前的一些指导原则。

* 使用在已命名的名称空间中声明的变量，而不是使用外部全局变量
* 使用在已命名的名称空间中声明的变量，而不是使用静态全局变量
* 如果开发了一个函数库或类库，将其凡在一个名称空间中。
* 仅将编译指令using作为一种将旧代码转换为使用名称空间的权益之计
* 不要在头文件中使用using编译指令。
* 导入名称时，首选使用作用域解析运算符或using声明的方法

​		名称空间的主旨是简化大型编程项目的管理工作。对于只有一个文件的简单程序，使用using编译指令并非是声明大逆不道之事。

​	
