# 第十二章 类和动态内存分配



##### 按值传递

​		在调用函数中将原函数的值拷贝一份过去被调用的函数，在被调用函数中对该值的修改不会影响原函数的值。



##### C++11空指针

​	C++11提供的专门来表示空指针的关键字：nullptr



### 本章概况

* 对类成员使用动态内存分配

* 显示和隐式复制构造函数

* 显示和隐式重载赋值运算符

* 在构造函数中使用new所必须完成的工作；

* 使用静态类成员；

* 将定位new运算符用于对象

* 使用指向对象的指针

  

​		介绍如何对类使用new和delete实现动态的内存管理以及如何处理由于使用动态内存而引起的一些微妙问题，这些问题将来可能会是你写的代码里的bug。C++因其特性复杂而闻名，特性复杂就难以掌控，C++之难可能就源于此。



## 动态内存和类

##### 例程

```C++
//strnbad.h
#include<iostream>

#ifndef STRNGBAD_H_
#define STRNGBAD_H_

class StringBad{
	private:
		char * str;
		int len;
		static int num_strings;	// num of objects
	public:
		StringBad(const char * s);
		StringBad();
		~StringBad();
	//friend Function
		friend std::ostream & operator<<(std::ostream & os, const StringBad & st);
};



#endif


//strngbad.cpp
// StringBad class methods
#include"strngbad.h"
using std::cout;

inline static int strlen(const char * arr){
	int num=0;
	while(*(arr+(num))!='\0')
		num++;
	return num;
}

inline static void strcpy(char * a, const char * b){
	int i;
	for(i = 0;*(b+i)!='\0';i++){
		*(a + i) = *(b + i);		
	}
	*(a + i + 1) = '\0';
}




//initializing static class member
int StringBad::num_strings = 0;

StringBad::StringBad(const char * s){
	this->len = strlen(s);
	this->str = new char[this->len + 1];
	strcpy(str,s);
	num_strings+=1;
	cout<< num_strings << ": \""<<this->str<< "\" object created\n";
}

StringBad::StringBad(){
	len = 4;
	str = new char[len];
	strcpy(str,"C++");
	cout<< num_strings << ": \""<< str << "\" default object created\n";
}

StringBad::~StringBad(){
	cout << "\"" << str<< "\" object delete, ";
	--num_strings;
	cout << num_strings << " left\n";
	delete [] str;
}



std::ostream & operator<<(std::ostream & os, const StringBad & st){
	os << st.str;
	return os; 
}


//vegnews.cpp
#include"strngbad.h"
using std::cout;



void callm1(StringBad &);
void callm2(StringBad &);

int main(){
	using std::endl;
	{
		cout << "Starting an inner block.\n";
		StringBad headline1("Celery Stalks at Midnight");
		StringBad headline2("Lettuce Prey");
		StringBad sports("Spinach Leaves Bowl for Dollars");
		
		cout << "headline1: " << headline1 << endl;
		cout << "headline2L " << headline2 << endl;
		
		cout << "sports: " << sports << endl;
		callm1(headline1);
		cout << "headline1: " << headline1 << endl;
		callm2(headline2);
		cout << "Initialize one object to another: \n";
		StringBad sailor = sports;
		cout << "Assign one object to another: \n";
		StringBad knot;
		knot = headline1;
		cout << "knot: " << knot << endl;
		cout << "Exiting the blocks.\n"; 
	}
	
	
	cout << "End of main() ";
	return 0;
	 
}
	
void callm1(StringBad & rsb){
	cout << "String passed by reference:\n";
	cout << " \"" << rsb << "\"\n";
}

void callm2(StringBad & sb){
	cout << "String passed by value:\n";
	cout << " \"" << sb << "\"\n"; 
}
```

​	

​	运行后会产生一些微妙的问题。这些问题由编译器自动生成的成员函数引起。

#### 类的特殊成员函数

​	用户自定义的类函数与特殊成员函数的设计不符，就会出现一些问题。C++自动地提供以下成员函数：

* 默认构造函数
* 默认析构函数
* 复制构造函数
* 赋值运算符
* 地址运算符

​	编译器将生成上述最后三个函数地定义——如果程序使用对象之方式要求这样做。例如，将一个对象赋给另外一个对象，编译器将提供赋值运算符的定义。
​	

##### 复制构造函数

​	复制构造函数用于将一个对象复制到新创建的对象中。也就是说，它用于初始化过程中（包括按值传递，当然是默认的复制构造函数，我们可以对其进行定义）。**他的原型如下**：

​		*Class_name( const Class_name & );*

##### 何时使用复制构造函数

​	**新建一个对象并将其初始化成为同类现有对象时**，复制构造函数将被调用。可以怎么说，**每当程序生成了对象副本，编译器都将使用复制构造函数**。

###### 		1.当函数按值传递对象时

​	按值传递对象意味着创建原石变量的一个**副本**，编译器将会调用复制构造函数。

###### 		2.当函数返回对象时

​	函数返回的对象，其实是该对象的一个**副本**，这时编译器将会调用复制构造函数。

##### 默认的复制构造函数的功能

​	默认的复制构造函数（我们没有对默认构造函数提供特定的定义时，系统在调用复制构造函数时，将会调用默认的复制构造函数）逐个复制**非静态成员**，复制的是成员的值。

#### 可能存在的问题



​	在临时对象被清除时，该临时对象的析构函数将会被调用，这可能会引起一些问题。举个例子，假如返回的临时对象os和对象sb里面的成员str（该成员是一个字符类型的指针： char *）指向同一地址。当临时对象被清除时，临时对象的析构函数将会释放该临时对象里的成员函数，也就是说，str所指向的地址将会被释放。当sb调用cout来显示它的成员str，将会出现一堆乱码。

​	试图释放内存两次可能导致程序中止，这也是潜在的问题。

​	这些都是内存管理不当的表现。

​	C++允许类赋值，这是通过自动地为类提供类重载赋值运算符实现的。将已有的对象副歌另外一个对象时，将会使用赋值运算符。 

```C++
String headline1 = StringBad("Celery Stalks at Midnight");
...
String knot;
knot = headline1; // 将使用赋值运算符。
```

​	与复制构造函数相似。赋值运算符的隐式实现也是对成员逐个进行复制。如果成员本身是个类对象，则使用为这个类定义的赋值运算符来复制该成员，但静态数据函数不受影响。

​	上面所显示的程序实现了将headline1赋值给knot，其中，headline1的成员str和knot的成员str指向了同一地址（赋值运算符的隐式实现也是对成员逐个进行复制）。

​	对knot调用析构函数时，它的析构函数将会释放其str所指向的地址，但headline1的成员str和knot的成员str指向了同一地址，此时，无论是使用headline1的成员str还是调用析构函数，都会出现问题（例如，用cout显示str，将会出现一堆乱码；重复释放已经释放过的地址，将会导致程序非正常关闭或奔溃等）。



#### 解决策略

###### 		定义一个显示的复制构造函数以解决问题

​	解决类设计中这种问题的方法是进行深度复刻（ deep copy ）。也就是说，复制构造函数应当创造字符串副本并将该副本的地址赋给str成员，而不是仅仅简单的复制字符串地址。这样，每个对象都有自己的字符串，调用析构函数时将释放不同的字符串地址。

​	

```C++
StringBad::StringBad(const StringBad & s){		//使用引用，不会创建新的对象副本
	this->len = strlen(s.str);
	this->str = new char[this->len + 1]; //创建新的字符串副本
	strcpy(str,s.str);		// 赋值
	num_strings+=1;
	cout<< num_strings << ": \""<<this->str<< "\" object created\n";
}
```

​	

###### 	解决赋值的问题

​	对于由于默认的赋值运算符调用出现的问题，解决办法是提供赋值运算符（进行深度复制）的定义。其实现与复制构造函数相似，但也有一些差别:

* 由于目标对象可能引用了以前分配的数据，收益函数应使用delete[]来释放这些数据

* 函数应当避免将对象赋给自身；否者，给对象重新赋值前，释放内存可能删除对象的内容

* 函数返回一个指向对象的引用

  

​	通过返回一个对象，函数就可以像常规赋值操作一样	，进行连续赋值。以下是改动：

```C++
StringBad & StringBad::operator=(const StringBad & st){
	if( this == &st )	// object assigned to itself
		return *this;	// all done
		
	delete [] str;		// free old string adress.
	len = st.len;		
	str = new char [len+1];		// get new space from memory
	strcpy(str,st.str);			// copy the string for st
	
	return *this;				// return reference to 										// invoking(调用) object
}
```

​	

### 在构造函数中使用new时应该注意的事项

​	 使用new初始化对象的指针成员必须非常小心。具体来说，有以下几个点（仅作参考）:

* 如果在构造函数里使用new来初始化对象，则应该在析构函数中使用delete。

* new和delete必须相互兼容。new对应delete，new[]对应于delete[];

* 如果有多个构造函数，则必须要用相同的方式使用new。以为只有一个析构函数。然而，可以在一个构造函数里使用new初始化指针，而在另外一个构造函数里使用空指针来初始化成员指针变量（0、NUL或nullptr，推荐使用nullptr）。

* 应定义一个复制构造函数，通过深度复制将一个对象初始化为另外一个对象。

* 应当定义一个赋值运算符，通过深度复制将一个对象复制给另外一个对象。

  

### 在下列情况下析构函数将被调用

- 如果对象是动态变量，则当执行完定义该对象的程序块时，将调用该对象的析构函数。
- 如果对象是动态变量，则在程序结束时将调用对象的析构函数
- 如果对象是用new创建，则仅当您显示地使用delete删除对象时，其构造函数才会被调用





### 成员初始化列表的语法

​		如果Classy是一个类，而mem1、 mem2、和mem3都是这个类的数据成员，则类的构造函数可以使用如下的算法来初始化数据成员：

```C++
Classy::Classy(int n, int m) :mem1(n), mem2(0), mem3(n*m+2){
    //....
}
```

​		上述代码将mem1初始化为n，将mem2初始化为0，将mem3初始化为n*m+2.这些操作是在对象创建时完成的。注意：

- 这种格式只能由于构造函数；
- 必须用这种格式来初始化非静态const数据成员；
- 必须用这种格式来初始化引用数据成员		
