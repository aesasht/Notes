# 第十一章	使用类



## 	前言

​			在第十章，主要介绍了定义和使用简单类的方法，并踏上了面向对象编程之路。学习到了俩个新特殊的成员函数——构造函数和析构函数，其作用是管理类的创建和删除。在第十一章中将继续探讨在C++中类的特性。重点是类的设计技术，而不是通用原理。
​			先是介绍运算符重载，他允许将标准的C++运算符（如=和+）用于类对象。然后介绍友元，这种C++机制使得非成员函数可以访问类的私有数据。最后介绍如何命令C++对类执行自动类型转换。学习本章和第12章，以对类构造函数和类析构函数所起的作用有更加深入的了解。
​			轻松地使用这种语言。不要觉得必须使用所有地特性，不要再第一次学习时就试图使用所有特性。

## 造轮子是什么？

​			显然，车轮子是圆形的，这是大家公认的，最合适的形状。而你非要发明另一种形状的轮子，这种行为就叫「重复发明轮子（Reinventing the wheel）」，即「造轮子」—— 明知道你做的不可能比前辈做得更好，却仍然坚持要做。

​			放到编程中，就是说业界已经有公认的软件或者库了，你明知道自己不可能比它做得更好，却还坚持要做。作为练习，造轮子可以增加自己的经验，很多事情看起来简单，但只有自己动手，才会发现其中的难点。当然实际开发中也有很多情况不得不造轮子，比如希望做到「自主知识产权」、刷 KPI 之类的；或者造轮子的人真的觉得自己开发的版本有更强的功能、更好的性能也说不定呢。

​			重复制造它的意义有两个 1：你的到了锻炼 2：你牛逼的话可以比前人造的更好，间接造福了全世界

​			重复制造轮子和重复发明轮子是不一样的。发明是researching，制造是engineering，不能混为一谈。我们说，不要重复发明轮子，但是没有说，不要重复制造轮子。

## 	一、运算符重载

​			运算符重载允许将重载的概念扩展到运算符上，允许赋予C++运算符多种含义。
​			C++允许将运算符重载扩展到用户定义的类型，例如，允许使用+将俩个对象相加。
​			要重载运算符，需要使用被称为运算符函数的特殊函数形式。运算符函数的格式如下：
​			

```C++
operatorop(argument-list); // This is a example
int operator+(const int & a){
	return this.value + a;\
} // A example too.
```

​			还有例如opertor*()重载 * 运算符。op（即opertorop里的op，代指运算符）必须是有效的C++运算符，不能虚构一个新的符号。例如，不能有operator@() 这样的函数。

#### 				运算符重载的限制

​			几条重要的
​			1.重载后的运算符必须至少有一个是用户自定义的类型，以防止用户为标准类型重载运算符。因此不能将double 的-运算重载为两个double 数的和。
​			2.使用运算符时不能违反运算符原来的句法规则。

## 二、友元函数

​			C++限制对类的私有成员的访问。一般地，类地公有成员是唯一的访问途径（即只能间接访问类私有成员）。C++提供另外一种访问类私有成员的方法，以应付特定的编程需求：友元。

​			友元分三种：

- ​				友元函数
- ​                友元类
- ​                友元成员函数			

​			通过让函数成为类的友元，可以赋予该函数与类的成员函数相同的访问权限。

### 为何需要友元

​			在为类重载二元运算符时常常需要友元。对运算符重载后，左侧的操作数必须是调用对象。

```C++
Temp Temp::operator*(const double & T) const;

Temp A = Temp();
Temp B = A *0.1; //情况1 这个情况可行
Temp C = 0.1*A   //情况2 这个情况不行，报错

```

​		从概念上看，情况1和情况2 是相同的，应该得出相同的结果。但运算符重载的性质使这个情况不可行。
​		有两种解决方案：一、告诉所有人，只能按照B = A * 0.1 这个形式去写；二、调用非成员函数：

```C++
Temp operator*(double m, const Temp & T);
```

​		引发一个新问题，即非成员函数无法直接访问私有成员变量。C++提供特殊的友元函数以解决此问题——友元函数。友元函数可以直接访问私有成员变量0，但不作为该类的成员函数。

### 创建友元函数

​			创建友元的第一步就是将其原型放在类声明中，并在其原型上加上关键字friend。

```C++
friend Temp operator*(double m, const Temp & t);
```

​			这样做意味着：一、operator * ()函数在类声明中声明的，但它不是成员函数，因此不能使用成员运算符来调用；二、虽然operator * ()函数不是成员函数，但它与成员函数访问权限相同。

​			第二步就是编写函数定义。因为它不是成员函数，所以不能使用 :: 限定符。另外，不要在定义中使用关键字friend。（友元函数可以说是常规的函数，就像C语言里的函数一样.

```C++
Temp operator*(double m, const Temp & t){
	// ToDo....
}
```

​			友元函数也是函数，也可以进行函数重载。并不是说这个友元函数用过那个运算符之后，该运算符就无法为另外夜歌友元函数所使用。

### 常用的友元：利用<<运算符

​			一个很有用的特性是，可以对<<运算符进行重载，使之能与cout来一起显示对象的内容。cout函数只支持对基本数据类型（如string、int、double、char等）使用<<运算符，无法识别用户自我定义的数据类型。一个可行的方法是修改iostream文件，将一个新的函数运算符定添加到ostream类声明中，但这是个危险的行为（不要问我为什么）我们可以通过类声明来让类知道如何使用cout。

#### 			1.<<第一种重载版本，使用友元函数

​			已知Time类如下所声明（定义略）

```C++
class Time{
	private:
		int hours;
		int minutes;
	public:
		Time();
		friend Time operator*(double m, const Time & T);
		Time(int h, int m = 0);
		inline AddMin(int m);
		inline AddHr(int h);
		inline Reset(int h = 0, int m = 0);
		Time operator+(const Time & t) const;	//运算符重载
		void Show() const;
		int Hour() const{
			return hours;
		}
		int Minute() const{
			return minutes;
		}
};
```

​			因为cout必须在左侧，这意味着，在Time类中对<<进行运算符重载毫无意义。（对Time进行运算符重载，使用该运算符时，Time类必须是第一操作数）。可以使用友元函数对<<进行重载。
​			

```C++
friend void operator<<(ostream & os, const Time & t);
```

​			以下是定义：

```C++
void operator<<(std::ostream & os, const Time & T){
	os << T.hours << "  Hours " << T.minutes <<"  minutes"<<std::endl;
}

```

#### 2.<<第二种重载版本

​			存在一个问题，无法做到：

```C++
cout<<"Trip Time: "<<trip<<" (Tuesday)\n";
```

​			以上语句相当于：

```C++
((cout<<"Trip Time: ")<<trip)<<" (Tuesday)\n";
```

​		正如iostream中定义的那样，<< 运算符要求左边是个ostream对象。因此cout<<"Trip Time: "返回的是一个cout对象。ostream 类将operator<<()函数实现返回为一个指向ostream对象的引用。这里它返回一个指向调用对象（即cout）。

​		可以对友元函数采用相同的办法。只要修改operator<<()函数，让它返回ostream对象的引用即可.

```C++
ostream & operator<<(std::ostream & os, const Time & T){
	os << T.hours << "  Hours " << T.minutes <<"  minutes"<<std::endl;
    return os; //对象os的类型是ostream对象的一个引用
}
```

​		

