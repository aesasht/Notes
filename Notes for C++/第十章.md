# 第十章		对象和类

​	

## C++中的类

​	类是一种将抽象转换为用户定义类型的C++工具，它将数据表示和操纵数据的方法组合成一个整洁的包。。
​	类声明提供了类的蓝图，类的方法定义则提供了细节。
​	

### 	声明C++类

​	C++运用关键字class来声明类。关键字private和public描述了对类成员的访问限制。不必在类中使用关键字private，因为这是类对象的默认访问控制。

```C++

// define in the file stock00.h
class Stock
{
	private:
		std::string company;
		long shares;
		double shares_val;
		double total_val;
		inline void set_tot(){ total_val = shares * shares_val;}
		
	public:
		void acqure(const std::string & co, long n, double pr);
		void buy(long num, double price);
		void sell(long num, double price);
		void update(double price);
		void show();
				
};
```



### 	实现类成员函数

​	定义于private域的类成员函数一般只能在类声明内部定义；
​	以下类成员函数指定义于public域内的类成员函数；
​	成员函数定义与常规函数定义非常相识，它们也有函数头和函数体，也可以有返回类型和返回参数。但是它们还有俩个特殊的特征：

* 定义成员函数（不在类声明中定义时），使用作用域解析运算符（::)来标识函数所属的类。
* 类方法可以访问类private域内的成员。

​	例如：

```c++
void Stock::update(double price){
    ......
}
```

​	

### 	使用类

​	C++的目的是使用使得使用类域使用基本的内置类型（如int和char）尽可能相同。要创建类对象，可以声明类变量，也可以使用new为类对象分配内存空间

## 类的构造函数和析构函数

​	应为类提供被称为构造函数和析构函数的标准函数。
​	为方便对一个对象的初始化，C++提供了一个成员函数——类构造函数，专门用于构造新对象，将值赋予它们的数据成员。

### 	声明和定义构造函数

​	现在需要创建Stock的构造函数。原型位于类声明的公有部分，其原型如下：

```C++
Stock(const string & co, long n = 0, double pr = 0.0);
```

​	可在公有区域为其提供定义。

### 	默认构造函数

​	默认构造函数是在未提供显示初始化时，用来创建对象的构造函数。为该对象提供默认的初始化。

```
Stock();	// 声明默认构造函数
Stock(){
	......	// 为其提供定义
}
```

### 	使用构造函数 

​	C++提供两种使用构造函数来初始化对象的方式。
​	第一种，显式地调用构造函数

```C++
Stock food = Stock("World Cabbage", 250, 1.25);
Stock food = Stock();	// 使用默认的构造函数
```

​	第二种，隐式地调用构造函数

```C++
Stock garment("Furry Mason",50,2.5);
```



### 	什么是析构函数

​	用构造函数创建对象后，程序负责跟踪该对象，直到其过期为止。对象过期时，程序将自动调用一个特殊的成员函数，该函数的名称令人生畏——析构函数。析构函数完成清理工作，因此实际上很有用。
​	例如，如果构造函数使用new来分配内存，则析构函数将使用delete来释放这些内存。

### 	声明和定义析构函数

​	和构造函数一样，析构函数的名称也很特殊：在类名称前加上~。因此Stock类的析构函数就是~Stock().
另外，和构造函数一样，析构函数也没有声明类型和返回值。与构造函数不同的是，析构函数没有参数。其原型必须是这样：

```C++
~Stock(){
	// TODO
}
```

​	析构函数将会在该对象过期时自动调用（如用new分配产生的对象将在使用关键字delete时调用该对象的析构函数）。

### 	C++11列表初始化

### 	const 成员函数

​	请看下面的代码片段

```C++
const Stock land = Stock("Kludgehorn Properties");
land.show();
```

​	对于当前的C++来说，编译器将拒接第二行。因为show()的代码无法确保调用对象不被修改——调用兑现和从上图一样，不应该被修改。我们以前通过将函数参数声明为const引用或指向const的指针来解决问题.但这里存在语法问题：show()方法没有任何参数。相反，它所有的对象是由方法调用隐式地提供地。需要一种新的语法——保证函数不会修改调用对象。C++地解决方法是将coonst关键字放在函数地看好后面。也就是说，show()声明应像这样：

```C++
void show() const;
```

​	同样，函数定义地开头应像这样：

```C++
void Stock::show() const // promises not to change invoking object
```

​	以这种方式声明和定义地类函数被称为从上图成员函数。就像应尽可能将从上图引用和指针用作函数形参一样，只要类方法不修改调用对象，就应将其声明为const。

## this指针

就是指针
